/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;\n\n//# sourceURL=webpack:///../node_modules/@babel/runtime/helpers/interopRequireDefault.js?");

/***/ }),

/***/ "../node_modules/audiobuffer-loader/index.js":
/*!***************************************************!*\
  !*** ../node_modules/audiobuffer-loader/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.ILoadAudioBufferResult = exports.loadAudioBuffer = void 0;\n\nvar _audiobufferLoader = __webpack_require__(/*! ./lib/audiobuffer-loader */ \"../node_modules/audiobuffer-loader/lib/audiobuffer-loader.js\");\n\nexports.loadAudioBuffer = _audiobufferLoader.loadAudioBuffer;\nexports.ILoadAudioBufferResult = _audiobufferLoader.ILoadAudioBufferResult;\n\n//# sourceURL=webpack:///../node_modules/audiobuffer-loader/index.js?");

/***/ }),

/***/ "../node_modules/audiobuffer-loader/lib/audiobuffer-loader.js":
/*!********************************************************************!*\
  !*** ../node_modules/audiobuffer-loader/lib/audiobuffer-loader.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.loadAudioBuffer = loadAudioBuffer;\n\n/**\n * Loads and decodes an audio-file, resulting in an AudioBuffer and the fileSize of the loaded file.\n * @param {AudioContext} context\n * @param {string} url\n * @param {(value: number) => void} onProgress\n * @returns {Promise<ILoadAudioBufferResult>}\n */\nfunction loadAudioBuffer(context, url, onProgress) {\n  return new Promise(function (resolve, reject) {\n    var request = new XMLHttpRequest();\n    request.open('GET', url, true);\n    request.responseType = 'arraybuffer'; // listen to onprogress events if onProgress was supplied\n\n    if (onProgress) {\n      request.onprogress = function (event) {\n        onProgress(event.loaded / event.total);\n      };\n    }\n\n    request.onload = function () {\n      if (request.status === 200) {\n        var _fileSize = request.response.byteLength;\n        var decodePromise = context.decodeAudioData(request.response, function (audioBuffer) {\n          resolve({\n            audioBuffer: audioBuffer,\n            fileSize: _fileSize\n          });\n        }, function (error) {\n          reject(error);\n        }); // not all implementations use this promise (was later added to the API). if they do\n        // we're catching (and ignoring) errors that may occur through here. these errors are\n        // handled by the onError method in the decodeAudioData call (3rd param)\n\n        if (decodePromise) {\n          decodePromise.catch(function () {});\n        }\n      } else {\n        reject(\"Error loading '\" + url + \"' (\" + request.status + \")\");\n      }\n    };\n\n    request.onerror = function (error) {\n      reject(error);\n    };\n\n    request.send();\n  });\n}\n\n//# sourceURL=webpack:///../node_modules/audiobuffer-loader/lib/audiobuffer-loader.js?");

/***/ }),

/***/ "../node_modules/musictime/index.js":
/*!******************************************!*\
  !*** ../node_modules/musictime/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"../node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _MusicTime = _interopRequireDefault(__webpack_require__(/*! ./lib/MusicTime */ \"../node_modules/musictime/lib/MusicTime.js\"));\n\nvar _default = _MusicTime.default;\nexports.default = _default;\n\n//# sourceURL=webpack:///../node_modules/musictime/index.js?");

/***/ }),

/***/ "../node_modules/musictime/lib/MusicTime.js":
/*!**************************************************!*\
  !*** ../node_modules/musictime/lib/MusicTime.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar MusicTime =\n/*#__PURE__*/\nfunction () {\n  /**\n   * hashmap for the results of toTime(bpm) calls\n   * @type {{}}\n   */\n  function MusicTime(bars, beats, sixteenths, beatsPerBar, sixteenthsPerBeat) {\n    if (beatsPerBar === void 0) {\n      beatsPerBar = 4;\n    }\n\n    if (sixteenthsPerBeat === void 0) {\n      sixteenthsPerBeat = 4;\n    }\n\n    Object.defineProperty(this, \"beatsPerBar\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"sixteenthsPerBeat\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"beats\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"bars\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"sixteenths\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: void 0\n    });\n    this.bars = bars;\n    this.beats = beats;\n    this.sixteenths = sixteenths;\n    this.beatsPerBar = beatsPerBar;\n    this.sixteenthsPerBeat = sixteenthsPerBeat;\n    this.normalize();\n  }\n\n  var _proto = MusicTime.prototype;\n\n  _proto.getCacheKey = function getCacheKey(bpm) {\n    // todo test this\n    return bpm + \"-\" + this.bars + \"-\" + this.beats + \"-\" + this.sixteenths + \"-\" + this.beatsPerBar + \"-\" + this.sixteenthsPerBeat;\n  };\n  /**\n   * Returns the time in seconds.\n   * @param bpm\n   * @returns {number}\n   */\n\n\n  _proto.toTime = function toTime(bpm) {\n    var cacheKey = this.getCacheKey(bpm);\n\n    if (MusicTime.TO_TIME_CACHE[cacheKey] === void 0) {\n      // no cached value exists\n      var beats = this.bars * this.beatsPerBar + this.beats + this.sixteenths / this.sixteenthsPerBeat; // add to cache hashmap\n\n      MusicTime.TO_TIME_CACHE[cacheKey] = beats * 60 / bpm;\n    }\n\n    return MusicTime.TO_TIME_CACHE[cacheKey];\n  };\n  /**\n   * Adds a musicTime to the instance.\n   * @param {MusicTime} time\n   * @returns {MusicTime}\n   */\n\n\n  _proto.add = function add(time) {\n    return MusicTime.add(this, time);\n  };\n  /**\n   * Subtracts a musicTime from the instance.\n   * @param {MusicTime} time\n   * @returns {MusicTime}\n   */\n\n\n  _proto.subtract = function subtract(time) {\n    return MusicTime.subtract(this, time);\n  };\n  /**\n   * Multiplies a musicTime with a scalar.\n   * @param {number} value\n   * @returns {MusicTime}\n   */\n\n\n  _proto.multiply = function multiply(value) {\n    return MusicTime.multiply(this, value);\n  };\n  /**\n   * Check if the instance is equal to another time.\n   * @param {MusicTime} time\n   * @returns {MusicTime}\n   */\n\n\n  _proto.equals = function equals(time) {\n    return MusicTime.equals(this, time);\n  };\n  /**\n   * Makes sure the beats don't exceed the beatsPerbar, and the sixteenths don't exceed sixteenthsPerBeat.\n   */\n\n\n  _proto.normalize = function normalize() {\n    var sixteenths = this.sixteenths % this.sixteenthsPerBeat;\n    var beatsFromSixteenths = Math.floor(this.sixteenths / this.sixteenthsPerBeat);\n    var beats = (this.beats + beatsFromSixteenths) % this.beatsPerBar;\n    var barsFromBeats = Math.floor((this.beats + beatsFromSixteenths) / this.beatsPerBar);\n    var bars = this.bars + barsFromBeats;\n    this.sixteenths = sixteenths;\n    this.beats = beats;\n    this.bars = bars;\n  };\n  /**\n   * Create a clone of the instance.\n   * @returns {MusicTime}\n   */\n\n\n  _proto.clone = function clone() {\n    return new MusicTime(this.bars, this.beats, this.sixteenths, this.beatsPerBar, this.sixteenthsPerBeat);\n  };\n  /**\n   * Gets the amount of sixteenths (will always be an integer since 16ths is the smallest grid)\n   * @returns {number}\n   */\n\n\n  _proto.toSixteenths = function toSixteenths() {\n    return this.sixteenths + this.sixteenthsPerBeat * this.beats + this.sixteenthsPerBeat * this.beatsPerBar * this.bars;\n  };\n  /**\n   * Gets the amount of bars (can be float)\n   * @returns {number}\n   */\n\n\n  _proto.toBarsFloat = function toBarsFloat() {\n    return this.bars + this.beats / this.beatsPerBar + this.sixteenths / this.sixteenthsPerBeat / this.beatsPerBar;\n  };\n  /**\n   * Gets the amount of bars (can be float)\n   * @returns {number}\n   */\n\n\n  _proto.toBeatsFloat = function toBeatsFloat() {\n    return this.bars * this.beatsPerBar + this.beats + this.sixteenths / this.sixteenthsPerBeat;\n  };\n\n  _proto.toString = function toString() {\n    return this.bars + '.' + this.beats + '.' + this.sixteenths;\n  };\n  /**\n   * Subtracts two MusicTimes.\n   * @param {MusicTime} time1\n   * @param {MusicTime} time2\n   * @returns {MusicTime}\n   */\n\n\n  MusicTime.subtract = function subtract(time1, time2) {\n    this.throwErrorWhenIncompatible('subtract', time1, time2);\n    return new MusicTime(0, 0, time1.toSixteenths() - time2.toSixteenths());\n  };\n  /**\n   * Creates an instance from a string: '0.1.2'\n   * @param value\n   * @param beatsPerBar\n   * @param sixteenthsPerBeat\n   * @returns {MusicTime}\n   */\n\n\n  MusicTime.fromString = function fromString(value, beatsPerBar, sixteenthsPerBeat) {\n    if (beatsPerBar === void 0) {\n      beatsPerBar = 4;\n    }\n\n    if (sixteenthsPerBeat === void 0) {\n      sixteenthsPerBeat = 4;\n    }\n\n    var split = value.split('.');\n\n    if (split.length !== 3) {\n      // todo add more validation\n      throw new Error('Invalid string');\n    }\n\n    return new MusicTime(parseInt(split[0], 10), parseInt(split[1], 10), parseInt(split[2], 10), beatsPerBar, sixteenthsPerBeat);\n  };\n\n  MusicTime.throwErrorWhenIncompatible = function throwErrorWhenIncompatible(operation, time1, time2) {\n    if (time1.beatsPerBar !== time2.beatsPerBar || time1.sixteenthsPerBeat !== time2.sixteenthsPerBeat) {\n      throw new Error(\"Cannot \" + operation + \" when beatsPerBar (\" + time1.beatsPerBar + \",\" + time2.beatsPerBar + \") or sixteenthsPerBeat (\" + time1.sixteenthsPerBeat + \",\" + time2.sixteenthsPerBeat + \") are not equal\");\n    }\n  };\n  /**\n   * Returns the sum of two times.\n   * @param {MusicTime} time1\n   * @param {MusicTime} time2\n   * @returns {MusicTime}\n   */\n\n\n  MusicTime.add = function add(time1, time2) {\n    MusicTime.throwErrorWhenIncompatible('add', time1, time2);\n    return new MusicTime(time1.bars + time2.bars, time1.beats + time2.beats, time1.sixteenths + time2.sixteenths); // todo fix with toValue(), like the other operations\n  };\n  /**\n   * Check if two times are equal.\n   * @param {MusicTime} time1\n   * @param {MusicTime} time2\n   * @returns {boolean}\n   */\n\n\n  MusicTime.equals = function equals(time1, time2) {\n    return time1.beatsPerBar === time2.beatsPerBar && time1.sixteenthsPerBeat === time2.sixteenthsPerBeat && time1.bars === time2.bars && time1.beats === time2.beats && time1.sixteenths === time2.sixteenths;\n  };\n  /**\n   * Returns the multiplication of a times with a value.\n   * @param {MusicTime} time\n   * @param {number} value\n   * @returns {MusicTime}\n   */\n\n\n  MusicTime.multiply = function multiply(time, value) {\n    return new MusicTime(0, 0, time.toSixteenths() * value);\n  };\n  /**\n   * Creates a MusicTime instance from an amount of seconds. Will be floored to the 16th grid,\n   * remaining time will be thrown away.\n   * @param {number} timeInSeconds\n   * @param {number} bpm\n   * @param {number} sixteenthsPerBeat\n   * @returns {MusicTime}\n   */\n\n\n  MusicTime.fromTime = function fromTime(timeInSeconds, bpm, sixteenthsPerBeat) {\n    if (sixteenthsPerBeat === void 0) {\n      sixteenthsPerBeat = 4;\n    }\n\n    var sixteenthsPerSecond = bpm * sixteenthsPerBeat / 60;\n    var sixteenthsUnrounded = timeInSeconds * sixteenthsPerSecond;\n    return new MusicTime(0, 0, Math.floor(sixteenthsUnrounded));\n  };\n\n  return MusicTime;\n}();\n\nexports.default = MusicTime;\nObject.defineProperty(MusicTime, \"TO_TIME_CACHE\", {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  value: {}\n});\n\n//# sourceURL=webpack:///../node_modules/musictime/lib/MusicTime.js?");

/***/ }),

/***/ "../node_modules/sample-manager/index.js":
/*!***********************************************!*\
  !*** ../node_modules/sample-manager/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"../node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nexports.__esModule = true;\nvar _exportNames = {};\nexports.default = void 0;\n\nvar _SampleManager = _interopRequireDefault(__webpack_require__(/*! ./lib/SampleManager */ \"../node_modules/sample-manager/lib/SampleManager.js\"));\n\nvar _utils = __webpack_require__(/*! ./lib/utils */ \"../node_modules/sample-manager/lib/utils.js\");\n\nObject.keys(_utils).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  exports[key] = _utils[key];\n});\n\nvar _interface = __webpack_require__(/*! ./lib/interface */ \"../node_modules/sample-manager/lib/interface.js\");\n\nObject.keys(_interface).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  exports[key] = _interface[key];\n});\nvar _default = _SampleManager.default;\nexports.default = _default;\n\n//# sourceURL=webpack:///../node_modules/sample-manager/index.js?");

/***/ }),

/***/ "../node_modules/sample-manager/lib/SampleManager.js":
/*!***********************************************************!*\
  !*** ../node_modules/sample-manager/lib/SampleManager.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _utils = __webpack_require__(/*! ./utils */ \"../node_modules/sample-manager/lib/utils.js\");\n\nvar SampleManager =\n/*#__PURE__*/\nfunction () {\n  function SampleManager(context, basePath, extension) {\n    Object.defineProperty(this, \"context\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"basePath\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"extension\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"samplesMap\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"isLoading\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: false\n    });\n    this.context = context;\n    this.basePath = basePath;\n    this.extension = extension;\n  }\n  /**\n   * Loads all samples that are currently present. Returns a promise.\n   * @param {(value: number) => void} onProgress\n   * @returns {Promise<void>}\n   */\n\n\n  var _proto = SampleManager.prototype;\n\n  _proto.loadAllSamples = function loadAllSamples(onProgress) {\n    return this.loadSamples(this.getAllSamples(), onProgress);\n  };\n  /**\n   * Loads a list of samples, returns a promise.\n   * @param {ISample[]} samples\n   * @param {(value: number) => void} onProgress\n   * @returns {Promise<void>}\n   */\n\n\n  _proto.loadSamples = function loadSamples(samples, onProgress) {\n    var _this = this;\n\n    // todo check if sample exists in this manager?\n    return new Promise(function (resolve, reject) {\n      if (_this.isLoading) {\n        reject('Already loading');\n      } else {\n        _this.isLoading = true;\n        (0, _utils.loadSamples)(_this.context, samples, _this.extension, _this.basePath, onProgress).then(function () {\n          _this.isLoading = false;\n          resolve();\n        });\n      }\n    });\n  };\n  /**\n   * Loads a list of samples by their names. Returned promise will be rejected if one or more\n   * samples can not be found (nothing will be loaded).\n   * @param {string[]} names\n   * @param {(value: number) => void} onProgress\n   * @returns {Promise<void>}\n   */\n\n\n  _proto.loadSamplesByName = function loadSamplesByName(names, onProgress) {\n    var _this2 = this;\n\n    // check if all samples exist in the manager\n    var results = {\n      foundSamples: [],\n      notFoundNames: []\n    };\n    names.forEach(function (name) {\n      if (_this2.samplesMap[name]) {\n        results.foundSamples.push(_this2.samplesMap[name]);\n      } else {\n        results.notFoundNames.push(name);\n      }\n    });\n\n    if (results.notFoundNames.length > 0) {\n      return Promise.reject(\"Loading samples failed: \" + results.notFoundNames.length + \" sample(s) not found in manager: \" + results.notFoundNames.join(', '));\n    }\n\n    return this.loadSamples(results.foundSamples, onProgress);\n  };\n  /**\n   * Gets the list of the current samples.\n   * @returns {ISample[]}\n   */\n\n\n  _proto.getAllSamples = function getAllSamples() {\n    var _this3 = this;\n\n    return Object.keys(this.samplesMap).map(function (key) {\n      return _this3.samplesMap[key];\n    });\n  };\n  /**\n   * Adds a sample to the manager. Throws an error when a sample with the same name already exists.\n   * @param {ICreateSample} createSample\n   */\n\n\n  _proto.addSample = function addSample(createSample) {\n    if (!this.samplesMap[createSample.name]) {\n      // create actual sample object\n      var sample = {\n        name: createSample.name,\n        fileName: createSample.fileName || createSample.name,\n        path: createSample.path || null,\n        extension: createSample.extension || null,\n        data: createSample.data || null,\n        audioBuffer: null,\n        fileSize: -1\n      }; // add to hashmap\n\n      this.samplesMap[sample.name] = sample;\n    } else {\n      throw new Error(\"Sample with name \" + createSample.name + \" already exists\");\n    }\n  };\n  /**\n   * Adds multiple samples to the manager. Throws an error when a sample with the same name already exists.\n   * @param {ICreateSample[]} samples\n   */\n\n\n  _proto.addSamples = function addSamples(samples) {\n    var _this4 = this;\n\n    samples.forEach(function (createSample) {\n      return _this4.addSample(createSample);\n    });\n  };\n  /**\n   * Creates and adds samples from a list of names.\n   * @param {string[]} names\n   */\n\n\n  _proto.addSamplesFromNames = function addSamplesFromNames(names) {\n    this.addSamples((0, _utils.createSamplesFromNames)(names));\n  };\n  /**\n   * Retrieves a sample by supplying a name.\n   * @param {string} name\n   * @returns {ISample}\n   */\n\n\n  _proto.getSampleByName = function getSampleByName(name) {\n    return this.samplesMap[name] || null;\n  };\n\n  return SampleManager;\n}();\n\nexports.default = SampleManager;\n\n//# sourceURL=webpack:///../node_modules/sample-manager/lib/SampleManager.js?");

/***/ }),

/***/ "../node_modules/sample-manager/lib/interface.js":
/*!*******************************************************!*\
  !*** ../node_modules/sample-manager/lib/interface.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack:///../node_modules/sample-manager/lib/interface.js?");

/***/ }),

/***/ "../node_modules/sample-manager/lib/utils.js":
/*!***************************************************!*\
  !*** ../node_modules/sample-manager/lib/utils.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.createSamplesFromNames = createSamplesFromNames;\nexports.loadSamples = loadSamples;\n\nvar _audiobufferLoader = __webpack_require__(/*! audiobuffer-loader */ \"../node_modules/audiobuffer-loader/index.js\");\n\n/**\n * Creates a list of ICreateSample instances with only the name-field set.\n * @param {string[]} names\n * @returns {ISample[]}\n */\nfunction createSamplesFromNames(names) {\n  return names.map(function (name) {\n    return {\n      name: name\n    };\n  });\n}\n/**\n * Loads a list of samples.\n * @param {AudioContext} context\n * @param {ISample[]} samples\n * @param {string} extension\n * @param {string} path\n * @param {(value: number) => void} onProgress\n * @returns {Promise<AudioBuffer[]>}\n */\n\n\nfunction loadSamples(context, samples, extension, path, onProgress) {\n  // if there is an onProgress supplied, we need to keep track of every samples' load progress\n  var callback;\n\n  if (onProgress) {\n    // create list of progress-values for all samples (set to 1 if they're loaded already)\n    var progressValues = samples.map(function (sample) {\n      return sample.audioBuffer ? 1 : 0;\n    }); // create the callback-method that is passed to every load action\n\n    callback = function callback(index, value) {\n      // set the correct progressValue for the sample that called it\n      progressValues[index] = value; // calculate the full progress to give back to the onProgress\n\n      onProgress(progressValues.reduce(function (acc, curr) {\n        return acc + curr;\n      }, 0) / progressValues.length);\n    };\n  } // create a list of promises for each load-action\n\n\n  var loadPromises = samples.map(function (sample, sampleIndex) {\n    if (sample.audioBuffer) {\n      return Promise.resolve();\n    } // construct url and load the buffer\n\n\n    var url = \"\" + path + (sample.path || '') + sample.fileName + \".\" + (sample.extension || extension);\n    return (0, _audiobufferLoader.loadAudioBuffer)(context, url, callback ? function (value) {\n      callback(sampleIndex, value);\n    } : null).then(function (result) {\n      // set resulting buffer on the sample object\n      sample.audioBuffer = result.audioBuffer;\n      sample.fileSize = result.fileSize;\n    });\n  });\n  return Promise.all(loadPromises).then(function () {\n    return;\n  });\n}\n\n//# sourceURL=webpack:///../node_modules/sample-manager/lib/utils.js?");

/***/ }),

/***/ "../node_modules/seng-disposable/index.js":
/*!************************************************!*\
  !*** ../node_modules/seng-disposable/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Disposable_1 = __webpack_require__(/*! ./lib/Disposable */ \"../node_modules/seng-disposable/lib/Disposable.js\");\nexports.default = Disposable_1.default;\n\n\n//# sourceURL=webpack:///../node_modules/seng-disposable/index.js?");

/***/ }),

/***/ "../node_modules/seng-disposable/lib/Disposable.js":
/*!*********************************************************!*\
  !*** ../node_modules/seng-disposable/lib/Disposable.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Disposable = (function () {\n    function Disposable() {\n        this.disposed = false;\n    }\n    /**\n     * After {@link dispose} has been called, this method returns true.\n     * Use this method to determine whether dispose() should be run again.\n     */\n    Disposable.prototype.isDisposed = function () {\n        return this.disposed;\n    };\n    /**\n     * Destruct this class.\n     */\n    Disposable.prototype.dispose = function () {\n        this.disposed = true;\n    };\n    return Disposable;\n}());\nexports.default = Disposable;\n\n\n//# sourceURL=webpack:///../node_modules/seng-disposable/lib/Disposable.js?");

/***/ }),

/***/ "../node_modules/seng-event/index.js":
/*!*******************************************!*\
  !*** ../node_modules/seng-event/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EventDispatcher_1 = __webpack_require__(/*! ./lib/EventDispatcher */ \"../node_modules/seng-event/lib/EventDispatcher.js\");\nvar EventPhase_1 = __webpack_require__(/*! ./lib/EventPhase */ \"../node_modules/seng-event/lib/EventPhase.js\");\nexports.EventPhase = EventPhase_1.default;\nvar EventListenerData_1 = __webpack_require__(/*! ./lib/EventListenerData */ \"../node_modules/seng-event/lib/EventListenerData.js\");\nexports.EventListenerData = EventListenerData_1.default;\nvar CallListenerResult_1 = __webpack_require__(/*! ./lib/CallListenerResult */ \"../node_modules/seng-event/lib/CallListenerResult.js\");\nexports.CallListenerResult = CallListenerResult_1.default;\nvar AbstractEvent_1 = __webpack_require__(/*! ./lib/AbstractEvent */ \"../node_modules/seng-event/lib/AbstractEvent.js\");\nexports.AbstractEvent = AbstractEvent_1.default;\nexports.default = EventDispatcher_1.default;\n\n\n//# sourceURL=webpack:///../node_modules/seng-event/index.js?");

/***/ }),

/***/ "../node_modules/seng-event/lib/AbstractEvent.js":
/*!*******************************************************!*\
  !*** ../node_modules/seng-event/lib/AbstractEvent.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar callListenerResult = 0 /* NONE */;\n/**\n * Abstract base class for all events that can be dispatched through [[EventDispatcher]]. This class\n * should not be instantiated but extended by a specific event class. For an event class with basic\n * functionality that can be instantiated see [[BasicEvent]]\n */\nvar AbstractEvent = (function () {\n    /**\n     * Creates a new AbstractEvent instance.\n     * @param type The type of the event. Event listeners will only be called if their eventType match this type.\n     * @param bubbles If true, the event will also go through a bubbling phase. See [[EventDispatcher.dispatchEvent]]\n     * for more information on the event phases.\n     * @param cancelable Indicates if [[preventDefault]] can be called on this event. This will prevent the 'default\n     * action' of the event from being executed. It is up to the [[EventDispatcher]] instance that dispatches the\n     * event to stop the default action from executing when the [[EventDispatcher.dispatchEvent|dispatchEvent]]\n     * method returns _false_\n     * @param setTimeStamp If true, will set the [[timeStamp]] property of this event to the current time whenever\n     * this event is dispatched.\n     */\n    function AbstractEvent(type, bubbles, cancelable, setTimeStamp) {\n        if (bubbles === void 0) { bubbles = false; }\n        if (cancelable === void 0) { cancelable = false; }\n        if (setTimeStamp === void 0) { setTimeStamp = false; }\n        this.type = type;\n        this.bubbles = bubbles;\n        this.cancelable = cancelable;\n        /**\n         * Will be updated by [[EventDispatcher]] during the dispatch of an event to the target that\n         * listeners are currently being called on. After completion of an event dispatch this value\n         * will be reset to _null_.\n         */\n        this.currentTarget = null;\n        /**\n         * Will be updated by [[EventDispatcher]] when [[EventDispatcher.dispatchEvent|dispatchEvent]] is\n         * called with this event. The value will be set to the EventDispatcher instance that dispatched\n         * the event.\n         */\n        this.target = null;\n        /**\n         * The current event phase of this event. During event dispatch, this value will be either\n         * [[EventPhase.CAPTURING_PHASE|CAPTURING_PHASE]], [[EventPhase.AT_TARGET|AT_TARGET]] or\n         * [[EventPhase.BUBBLING_PHASE|BUBBLING_PHASE]]. If this event is not currently being dispatched this will be\n         * set to [[EventPhase.NONE|NONE]].\n         */\n        this.eventPhase = 0 /* NONE */;\n        /**\n         *  _true_ if [[cancelable]] is true and [[preventDefault]] has been called on this event.\n         */\n        this.defaultPrevented = false;\n        this.timeStamp = setTimeStamp ? Date.now() : 0;\n    }\n    /**\n     * When called during the dispatch of an event, will prevent any targets further in the event chain\n     * from being processed. All listeners on the current target will still be executed.\n     * @see [[EventDispatcher.dispatchEvent]]\n     */\n    AbstractEvent.prototype.stopPropagation = function () {\n        if (callListenerResult < 1 /* PROPAGATION_STOPPED */) {\n            callListenerResult = 1 /* PROPAGATION_STOPPED */;\n        }\n    };\n    /**\n     * When called during the dispatch of an event, will prevent any other event listener from being\n     * called for this event.\n     * @see [[EventDispatcher.dispatchEvent]]\n     */\n    AbstractEvent.prototype.stopImmediatePropagation = function () {\n        callListenerResult = 2 /* IMMEDIATE_PROPAGATION_STOPPED */;\n    };\n    /**\n     * May only be called when the [[cancelable]] property of an event is set to _true_. Indicates to the\n     * instance that dispatched the event that the default action for the event should not be executed.\n     */\n    AbstractEvent.prototype.preventDefault = function () {\n        if (this.cancelable) {\n            this.defaultPrevented = true;\n        }\n        else {\n            throw new Error('Called preventDefault on a non-cancelable event');\n        }\n    };\n    /**\n     * Calls the given event handler, and returns an enum value that indicates if [[stopPropagation]] or\n     * [[stopImmediatePropagation]] have been called on this event during the execution of that handler.\n     * @param handler The event handler to execute\n     * @returns An enum value, see [[CallListenerResult]]\n     */\n    AbstractEvent.prototype.callListener = function (handler) {\n        callListenerResult = 0 /* NONE */;\n        handler.call(null, this);\n        return callListenerResult;\n    };\n    return AbstractEvent;\n}());\nexports.default = AbstractEvent;\n\n\n//# sourceURL=webpack:///../node_modules/seng-event/lib/AbstractEvent.js?");

/***/ }),

/***/ "../node_modules/seng-event/lib/CallListenerResult.js":
/*!************************************************************!*\
  !*** ../node_modules/seng-event/lib/CallListenerResult.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Enum that is returned by the [[AbstractEvent.callListener]] method\n */\nvar CallListenerResult;\n(function (CallListenerResult) {\n    /**\n     * Indicates that neither [[IEvent.stopPropagation|stopPropagation]] nor\n     * [[IEvent.stopImmediatePropagation|stopImmediatePropagation]] has been called\n     */\n    CallListenerResult[CallListenerResult[\"NONE\"] = 0] = \"NONE\";\n    /**\n     * Indicates that [[IEvent.stopPropagation|stopPropagation]] has been called, but\n     * [[IEvent.stopImmediatePropagation|stopImmediatePropagation]] hasn't\n     */\n    CallListenerResult[CallListenerResult[\"PROPAGATION_STOPPED\"] = 1] = \"PROPAGATION_STOPPED\";\n    /**\n     * Indicates that [[IEvent.stopImmediatePropagation|stopImmediatePropagation]] has been called\n     */\n    CallListenerResult[CallListenerResult[\"IMMEDIATE_PROPAGATION_STOPPED\"] = 2] = \"IMMEDIATE_PROPAGATION_STOPPED\";\n})(CallListenerResult || (CallListenerResult = {}));\nexports.default = CallListenerResult;\n\n\n//# sourceURL=webpack:///../node_modules/seng-event/lib/CallListenerResult.js?");

/***/ }),

/***/ "../node_modules/seng-event/lib/EventDispatcher.js":
/*!*********************************************************!*\
  !*** ../node_modules/seng-event/lib/EventDispatcher.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"../node_modules/tslib/tslib.es6.js\");\nvar seng_disposable_1 = __webpack_require__(/*! seng-disposable */ \"../node_modules/seng-disposable/index.js\");\nvar EventListenerData_1 = __webpack_require__(/*! ./EventListenerData */ \"../node_modules/seng-event/lib/EventListenerData.js\");\n/**\n * Base class that adds the ability to dispatch events and attach handlers that should be\n * called when such events are triggered.\n *\n * This EventDispatcher also supports event capturing and bubbling phases, heavily inspired\n * by existing event dispatching systems like the functionality described in the\n * [DOM Event W3 spec](https://www.w3.org/TR/DOM-Level-2-Events/events.html)\n */\nvar EventDispatcher = (function (_super) {\n    tslib_1.__extends(EventDispatcher, _super);\n    /**\n     * Creates an EventDispatcher instance.\n     * @param parent If set, registers the given EventDispatcher instance as parent. This\n     * child-parent relationship is used in the event chain during the capture phase of\n     * events and the bubbling phase of bubbling events. For more information on event\n     * bubbling and capturing, see [[dispatchEvent]]\n     * @param target If set, will set the [[IEvent.target|target]] attribute of all events\n     * dispatched by this EventDispatcher to the given object. If not set, will use this instance\n     * as a target for dispatched events.\n     */\n    function EventDispatcher(parent, target) {\n        if (parent === void 0) { parent = null; }\n        var _this = _super.call(this) || this;\n        /**\n         * An object containing all event listeners by [[IEvent.type|event type]]. Each value\n         * on this object is an Array of [[EventListenerData]] objects for each event listener\n         * added with that type.\n         */\n        _this.listeners = {};\n        _this.target = target || _this;\n        _this.parent = parent;\n        return _this;\n    }\n    /**\n     * Dispatches the given event. The dispatch consists of three phases:\n     * 1. The capture phase. We walk through all ancestors of this EventDispatcher, with the\n     * top-most instance first and the direct parent of this EventDispatcher last. On each\n     * ancestor, we call all event handlers that are added with the _useCapture_ argument\n     * set to _true_ and the _eventType_ set to the same [[IEvent.type|type]] as\n     * the given event.\n     * If this EventDispatcher has no parent, this phase will be skipped.\n     * 2. The target phase. In this phase we call all event handlers on this EventDispatcher\n     * instance that listen for the same [[IEvent.type|type]] as the given event.\n     * 3. The bubbling phase. This phase will only be executed if the given event has the\n     * [[IEvent.bubbles|bubbles]] property set to _true_. If so, we will again walk through\n     * all ancestors of this EventDispatcher, but in the reverse order: the direct parent\n     * of this instance first and the top-most parent last. On every ancestor, we will call\n     * all event handlers that are added with the _useCapture_ argument set to _false_ and the\n     * _eventType_ set to the same [[IEvent.type|type]] as the given event.\n     *\n     * If any of the event handlers call [[IEvent.stopPropagation|stopPropagation()]], we will\n     * skip all event handlers that occur on a target later in the event chain. If an event handler\n     * calls [[IEvent.stopImmediatePropagation|stopImmediatePropagation()]], we will also skip\n     * any event handlers on the same target in the event chain.\n     * @param event The event to dispatch\n     * @returns If one of the handlers that have been called during this dispatch\n     * called [[IEvent.preventDefault|event.preventDefault()]], this method will return _false_.\n     * If no handlers have been called or none of the handlers have called\n     * [[IEvent.preventDefault|event.preventDefault()]], this method will return _true_.\n     *\n     * _Please note: [[IEvent.preventDefault|preventDefault()]] can only be called on\n     * events that have their [[IEvent.cancelable|cancelable]] property set to true_\n     */\n    EventDispatcher.prototype.dispatchEvent = function (event) {\n        if (this.isDisposed()) {\n            throw new Error('Can\\'t dispatchEvent on a disposed EventDispatcher');\n        }\n        else {\n            // todo: on debug builds, check willTrigger and log if false\n            var callTree = exports.getCallTree(this, event.bubbles);\n            event.target = this.target;\n            event.eventPhase = callTree.length === 1 ? 2 /* AT_TARGET */ : 1 /* CAPTURING_PHASE */;\n            for (var i = 0; i < callTree.length; i += 1) {\n                var currentTarget = callTree[i];\n                event.currentTarget = currentTarget;\n                if (currentTarget === this) {\n                    event.eventPhase = 2 /* AT_TARGET */;\n                }\n                var propagationIsStopped = exports.callListeners(currentTarget.listeners, event);\n                if (propagationIsStopped) {\n                    event.eventPhase = 0 /* NONE */;\n                    break;\n                }\n                if (i === callTree.length - 1) {\n                    // after last target in tree, reset eventPhase to NONE\n                    event.eventPhase = 0 /* NONE */;\n                }\n                else if (currentTarget === this) {\n                    // after target === currentTarget we will enter the bubbling phase\n                    event.eventPhase = 3 /* BUBBLING_PHASE */;\n                }\n            }\n            event.currentTarget = null;\n            return !event.defaultPrevented;\n        }\n    };\n    /**\n     * Adds a new event listener. The given handler function will be called in the following cases:\n     *  - An event with a [[IEvent.type|type]] that is equal to the given _eventType_ is dispatched\n     *  on this EventDispatcher instance.\n     *  - An event with a [[IEvent.type|type]] that is equal to the given _eventType_ is dispatched\n     *  on a child EventDispatcher, and the _useCapture_ parameter is set to _true_\n     *  - An event with [[IEvent.bubbles|bubbles]] set to _true_ and a [[IEvent.type|type]] that\n     *  is equal to the given _eventType_ is dispatched on a child EventDispatcher, and the\n     *  _useCapture_ parameter is set to _false_\n     *\n     * @see [[dispatchEvent]] for more info on the which event listeners are called during\n     * capturing and bubbling\n     * @param eventType The eventType to listen for\n     * @param handler The handler function that will be called when a matching event is dispatched.\n     * This function will retrieve the dispatched [[IEvent|event]] as a parameter\n     * @param useCapture Indicates if this handler should be called during the capturing phase\n     * of an event chain. If and only if this is set to _false_ will this handler be called\n     * during the bubbling phase of an event chain.\n     * @param priority A number that indicates the priority of this event listener relative\n     * to other event listeners of the same type on this EventDispatcher instance. A higher number\n     * indicates that this listener will be called earlier.\n     * @returns An object describing the listener that has a [[EventListenerData.dispose|dispose()]]\n     * method to remove the listener.\n     */\n    EventDispatcher.prototype.addEventListener = function (eventType, handler, useCapture, priority) {\n        if (useCapture === void 0) { useCapture = false; }\n        if (priority === void 0) { priority = 0; }\n        if (typeof (this.listeners[eventType]) === 'undefined') {\n            this.listeners[eventType] = [];\n        }\n        var data = new EventListenerData_1.default(this, eventType, handler, useCapture, priority);\n        this.listeners[eventType].push(data);\n        this.listeners[eventType].sort(this.listenerSorter);\n        return data;\n    };\n    /**\n     * Checks if an event listener matching the given parameters exists on this EventDispatcher\n     * instance.\n     * @param eventType Will only look for event listeners with this _eventType_\n     * @param handler If set, will only match event listeners that have the same handler function\n     * @param useCapture If set, will only match event listeners that have the same _useCapture_\n     * argument. _Please note: if no useCapture argument was provided to [[addEventListener]], it\n     * is set to false by default_\n     * @returns {boolean} True if one or more event listeners exist\n     */\n    EventDispatcher.prototype.hasEventListener = function (eventType, handler, useCapture) {\n        if (typeof handler === 'undefined') {\n            return !!this.listeners[eventType] && this.listeners[eventType].length > 0;\n        }\n        else if (!this.listeners[eventType]) {\n            return false;\n        }\n        else {\n            for (var i = 0; i < this.listeners[eventType].length; i += 1) {\n                var listenerData = this.listeners[eventType][i];\n                if (listenerData.handler === handler &&\n                    (typeof useCapture === 'undefined' || useCapture === listenerData.useCapture)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n    /**\n     * Checks if an event listener with a [[EventListenerData.type|type]] of the given _eventType_ exists\n     * on this EventDispatcher or any ancestor EventDispatcher instance.\n     * @param eventType The event type to check for\n     * @returns _true_ if a matching listener is found\n     */\n    EventDispatcher.prototype.willTrigger = function (eventType) {\n        return this.hasEventListener(eventType) || (!!this.parent && this.parent.willTrigger(eventType));\n    };\n    /**\n     * Removes all event listeners that match the given parameters from this EventDispatcher\n     * instance.\n     *\n     * _Please note: if you remove an event listener during the dispatch of an event it will\n     * not be called anymore, even if it was supposed to be called in the same event chain_\n     * @param eventType Only event listeners of that have this _eventType_ are removed\n     * @param handler Only event listeners that have this handler function will be removed\n     * @param useCapture Only event listeners that have been added with the same _useCapture_\n     * parameter will be removed. _Please note: if no useCapture argument is provided, only\n     * event listeners that have useCapture set to false will be removed._\n     */\n    EventDispatcher.prototype.removeEventListener = function (eventType, handler, useCapture) {\n        if (useCapture === void 0) { useCapture = false; }\n        exports.removeListenersFrom(this.listeners, eventType, handler, useCapture);\n    };\n    /**\n     * Removes all event listeners that have a [[IEvent.type|type]] of the given _eventType_\n     * from this EventDispatcher instance, regardless of their [[EventListenerData.handler|handler]] or\n     * [[EventListenerData.useCapture|useCapture]] property.\n     *\n     * _Please note: if you remove an event listener during the dispatch of an event it will\n     * not be called anymore, even if it was supposed to be called in the same event chain_\n     * @param eventType The [[IEvent.type|type]] of event to remove. If not provided, all event listeners\n     * will be removed regardless of their type.\n     */\n    EventDispatcher.prototype.removeAllEventListeners = function (eventType) {\n        exports.removeListenersFrom(this.listeners, eventType);\n    };\n    /**\n     * Cleans up this EventListener instance. No event handlers on this EventDispatcher will be called\n     * and future calls to dispatchEvent() will be ignored.\n     */\n    EventDispatcher.prototype.dispose = function () {\n        this.removeAllEventListeners();\n        _super.prototype.dispose.call(this);\n    };\n    /**\n     * Method that is used to sort arrays of event listeners based on their [[EventListenerData.priority|priority]]\n     * property. Higher priority will be sorted before lower priority values.\n     * @param e1 The first event listener to compare\n     * @param e2 The other event listener to compare to\n     * @returns A number that indicates the sorting according to the JS sort() method.\n     */\n    EventDispatcher.prototype.listenerSorter = function (e1, e2) {\n        return e2.priority - e1.priority;\n    };\n    return EventDispatcher;\n}(seng_disposable_1.default));\nexports.default = EventDispatcher;\n/**\n * Helper function for [[EventDispatcher.removeEventListener]] and [[EventDispatcher.removeAllEventListeners]].\n * Will remove all event listeners that match the given parameters from the given event listener map object.\n * This function differs from [[EventDispatcher.removeEventListener|removeEventListener()]] in that it does not\n * use default values when you emit one of the parameters. Instead, it will remove event listeners of all\n * possible values for that parameter.\n * @param listeners A map of listeners to remove from. See [[EventDispatcher.listeners]]\n * @param eventType If set, will only remove listeners added with this _eventType_\n * @param handler If set, will only remove listeners with this _handler_\n * @param useCapture If set, will only remove listeners with the same value for _useCapture_\n */\nexports.removeListenersFrom = function (listeners, eventType, handler, useCapture) {\n    for (var i in listeners) {\n        if (listeners.hasOwnProperty(i)) {\n            var matchesEventType = !eventType || i === eventType;\n            if (matchesEventType && listeners.hasOwnProperty(i) && listeners[i] instanceof Array) {\n                var listenersForType = listeners[i];\n                // traverse the array in reverse. this will make sure removal does not affect the loop\n                for (var j = listenersForType.length; j; j -= 1) {\n                    var listenerData = listenersForType[j - 1];\n                    if ((!handler || handler === listenerData.handler) &&\n                        (typeof useCapture === 'undefined' || !!useCapture === listenerData.useCapture)) {\n                        listenersForType.splice(j - 1, 1);\n                        // mark the listener as removed, because it might still be active in the current event loop\n                        listenerData.isRemoved = true;\n                    }\n                }\n                // If an eventType was provided, this will be the only property where we need to remove listeners\n                if (eventType) {\n                    break;\n                }\n            }\n        }\n    }\n};\n/**\n * Gets an array of all parent EventDispatcher instances of the given EventDispatcher. The direct\n * parent (if it has one) will be first in the Array, and the most top-level parent will be last.\n * @param target The instance to get parents for\n * @returns {Array<EventDispatcher>} The array of parents\n */\nexports.getParents = function (target) {\n    var currentTarget = target;\n    var parents = [];\n    while (currentTarget.parent) {\n        currentTarget = currentTarget.parent;\n        parents.push(currentTarget);\n    }\n    return parents;\n};\n/**\n * Gets an array that represents the entire call tree when an event is dispatched on the given target.\n * See [[EventDispatcher.dispatchEvent]] for more information on the event phases\n * @param target The target to get the call tree for\n * @param bubbles If true, will also include the target instances of the _bubbling_ phase. If false, will\n * only include the _capture_ and target_ phases.\n * @returns An array of EventDispatcher instances in the order that an event will travel during dispatch\n * on the given target.\n */\nexports.getCallTree = function (target, bubbles) {\n    var callTree = [];\n    var parents = exports.getParents(target);\n    for (var i = parents.length; i; i -= 1) {\n        callTree.push(parents[i - 1]);\n    }\n    callTree.push(target);\n    if (bubbles) {\n        Array.prototype.push.apply(callTree, parents);\n    }\n    return callTree;\n};\n/**\n * Calls all listeners on the given event listener map that should be called when the given event is\n * dispatched. If no matching listeners are present, this function has no effect\n * @param listeners The object that contains listeners to call. Has the same format as the\n * [[EventDispatcher.listeners|listeners]] property on [[EventDispatcher]]\n * @param event The event that may trigger listeners in the map\n * @returns True if any of the listeners call [[IEvent.stopPropagation|stopPropagation()]] or\n * [[IEvent.stopImmediatePropagation|stopImmediatePropagation]]. False if no listeners are called or none\n * of them call [[IEvent.stopPropagation|stopPropagation()]] or\n * [[IEvent.stopImmediatePropagation|stopImmediatePropagation]]\n */\nexports.callListeners = function (listeners, event) {\n    var listenersOfType = listeners[event.type] ? listeners[event.type].slice() : [];\n    var propagationIsStopped = false;\n    for (var i = 0; i < listenersOfType.length; i += 1) {\n        var disabledOnPhase = listenersOfType[i].useCapture ? 3 /* BUBBLING_PHASE */ : 1 /* CAPTURING_PHASE */;\n        if (event.eventPhase !== disabledOnPhase && !listenersOfType[i].isRemoved) {\n            var callResult = event.callListener(listenersOfType[i].handler);\n            if (callResult > 0 /* NONE */) {\n                propagationIsStopped = true;\n                if (callResult === 2 /* IMMEDIATE_PROPAGATION_STOPPED */) {\n                    break;\n                }\n            }\n        }\n    }\n    return propagationIsStopped;\n};\n\n\n//# sourceURL=webpack:///../node_modules/seng-event/lib/EventDispatcher.js?");

/***/ }),

/***/ "../node_modules/seng-event/lib/EventListenerData.js":
/*!***********************************************************!*\
  !*** ../node_modules/seng-event/lib/EventListenerData.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"../node_modules/tslib/tslib.es6.js\");\nvar seng_disposable_1 = __webpack_require__(/*! seng-disposable */ \"../node_modules/seng-disposable/index.js\");\n/**\n * Data object that is created on every call to [[EventDispatcher.addEventListener]]. The object is\n * saved on the [[EventDispatcher.listeners]] object for internal use but is also returned by the\n * _addEventListener_ method as a way to remove the listener.\n */\nvar EventListenerData = (function (_super) {\n    tslib_1.__extends(EventListenerData, _super);\n    /**\n     * @param dispatcher The EventDispatcher on which this listener listens for events\n     * @param type The type of event this listener responds to\n     * @param handler The handler function that will be called when a matching event is dispatched\n     * @param useCapture Set to the _useCapture_ argument passed to [[EventDispatcher.addEventListener|addEventListener]]\n     * @param priority Set to the _priority_ argument passed to [[EventDispatcher.addEventListener|addEventListener]].\n     * Used to sort the listener within the [[EventDispatcher._listeners|_listeners]] object of the EventDispatcher\n     */\n    function EventListenerData(dispatcher, type, handler, useCapture, priority) {\n        var _this = _super.call(this) || this;\n        _this.dispatcher = dispatcher;\n        _this.type = type;\n        _this.handler = handler;\n        _this.useCapture = useCapture;\n        _this.priority = priority;\n        /**\n         * This property will be set to _true_ by the [[EventDispatcher]] this listener is bound to when\n         * the listener is removed. This is to make sure the handler is not called, even if the listener\n         * is removed while dispatching the event.\n         */\n        _this.isRemoved = false;\n        return _this;\n    }\n    /**\n     * Detaches this event listener from its EventDispatcher. The handler function on this listener will\n     * no longer be called in response to dispatched events.\n     */\n    EventListenerData.prototype.dispose = function () {\n        if (this.dispatcher) {\n            this.dispatcher.removeEventListener(this.type, this.handler, this.useCapture);\n            this.dispatcher = null;\n        }\n        _super.prototype.dispose.call(this);\n    };\n    return EventListenerData;\n}(seng_disposable_1.default));\nexports.default = EventListenerData;\n\n\n//# sourceURL=webpack:///../node_modules/seng-event/lib/EventListenerData.js?");

/***/ }),

/***/ "../node_modules/seng-event/lib/EventPhase.js":
/*!****************************************************!*\
  !*** ../node_modules/seng-event/lib/EventPhase.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * An enum for possible event phases that an event can be in\n */\nvar EventPhase;\n(function (EventPhase) {\n    /**\n     * Indicates that the event is currently not being dispatched\n     */\n    EventPhase[EventPhase[\"NONE\"] = 0] = \"NONE\";\n    /**\n     * Indicates that the event is in the capturing phase, moving down from the top-most EventDispatcher\n     * instance to the parent of the target EventDispatcher\n     */\n    EventPhase[EventPhase[\"CAPTURING_PHASE\"] = 1] = \"CAPTURING_PHASE\";\n    /**\n     * Indicates that we are currently calling the event listeners on the event target during dispatch.\n     */\n    EventPhase[EventPhase[\"AT_TARGET\"] = 2] = \"AT_TARGET\";\n    /**\n     * Indicates that we are currently moving back up from the parent of the target EventDispatcher to\n     * the top-most EventDispatcher instance.\n     */\n    EventPhase[EventPhase[\"BUBBLING_PHASE\"] = 3] = \"BUBBLING_PHASE\";\n})(EventPhase || (EventPhase = {}));\nexports.default = EventPhase;\n\n\n//# sourceURL=webpack:///../node_modules/seng-event/lib/EventPhase.js?");

/***/ }),

/***/ "../node_modules/tslib/tslib.es6.js":
/*!******************************************!*\
  !*** ../node_modules/tslib/tslib.es6.js ***!
  \******************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__extends\", function() { return __extends; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__assign\", function() { return __assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__rest\", function() { return __rest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__decorate\", function() { return __decorate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__param\", function() { return __param; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__metadata\", function() { return __metadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__awaiter\", function() { return __awaiter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__generator\", function() { return __generator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__exportStar\", function() { return __exportStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__values\", function() { return __values; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__read\", function() { return __read; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__spread\", function() { return __spread; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__await\", function() { return __await; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncGenerator\", function() { return __asyncGenerator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncDelegator\", function() { return __asyncDelegator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__asyncValues\", function() { return __asyncValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__makeTemplateObject\", function() { return __makeTemplateObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__importStar\", function() { return __importStar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__importDefault\", function() { return __importDefault; });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nfunction __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\n\n//# sourceURL=webpack:///../node_modules/tslib/tslib.es6.js?");

/***/ }),

/***/ "../src/lib/SamplePlayer.ts":
/*!**********************************!*\
  !*** ../src/lib/SamplePlayer.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst webAudioUtils_1 = __webpack_require__(/*! ./util/webAudioUtils */ \"../src/lib/util/webAudioUtils.ts\");\r\nclass SamplePlayer {\r\n    constructor(context, output) {\r\n        this.playingSamples = [];\r\n        this.context = context;\r\n        this.output = output;\r\n    }\r\n    playSample(data, playStartTime) {\r\n        const event = data.event;\r\n        const playResult = webAudioUtils_1.playBuffer(this.context, this.output, event.sample.audioBuffer, data.absoluteSeconds + playStartTime, // start time\r\n        0, // play from\r\n        -1, // play to\r\n        event.volume);\r\n        // add to list to keep track of playing samples\r\n        this.playingSamples.push(playResult);\r\n        // when playing is done, remove from list\r\n        playResult.bufferSourceNode.onended = () => {\r\n            const index = this.playingSamples.indexOf(playResult);\r\n            if (index > -1) {\r\n                this.playingSamples.splice(index, 1);\r\n            }\r\n        };\r\n    }\r\n    stopAll() {\r\n        this.playingSamples.forEach(item => {\r\n            item.bufferSourceNode.stop(0);\r\n            item.bufferSourceNode.disconnect();\r\n            item.gainNode.disconnect();\r\n        });\r\n        this.playingSamples = [];\r\n    }\r\n}\r\nexports.default = SamplePlayer;\r\n\n\n//# sourceURL=webpack:///../src/lib/SamplePlayer.ts?");

/***/ }),

/***/ "../src/lib/SequencePlayer.ts":
/*!************************************!*\
  !*** ../src/lib/SequencePlayer.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst scheduleUtils_1 = __webpack_require__(/*! ./util/scheduleUtils */ \"../src/lib/util/scheduleUtils.ts\");\r\nconst Interval_1 = __webpack_require__(/*! ./util/Interval */ \"../src/lib/util/Interval.ts\");\r\nconst sample_manager_1 = __webpack_require__(/*! sample-manager */ \"../node_modules/sample-manager/index.js\");\r\nconst seng_event_1 = __webpack_require__(/*! seng-event */ \"../node_modules/seng-event/index.js\");\r\nconst songUtils_1 = __webpack_require__(/*! ./util/songUtils */ \"../src/lib/util/songUtils.ts\");\r\nconst SamplePlayer_1 = __webpack_require__(/*! ./SamplePlayer */ \"../src/lib/SamplePlayer.ts\");\r\nconst enum_1 = __webpack_require__(/*! ./data/enum */ \"../src/lib/data/enum.ts\");\r\nconst event_1 = __webpack_require__(/*! ./data/event */ \"../src/lib/data/event.ts\");\r\nconst AnimationFrame_1 = __webpack_require__(/*! ./util/AnimationFrame */ \"../src/lib/util/AnimationFrame.ts\");\r\nconst sequencePlayerUtils_1 = __webpack_require__(/*! ./util/sequencePlayerUtils */ \"../src/lib/util/sequencePlayerUtils.ts\");\r\nconst musictime_1 = __webpack_require__(/*! musictime */ \"../node_modules/musictime/index.js\");\r\nclass SequencePlayer extends seng_event_1.default {\r\n    constructor(context, samplesBasePath, samplesExtension) {\r\n        super();\r\n        this.timeData = sequencePlayerUtils_1.initTimeData();\r\n        this.state = enum_1.SequencePlayerState.IDLE;\r\n        this.scheduleTime = { interval: 1, lookAhead: 1.5 };\r\n        this.onScheduleInterval = () => {\r\n            // todo for now this is ok, but with loops songs can not have an and-time\r\n            if (this.getSongPlayTime() > this.song.getSongEndTime().toTime(this.song.bpm)) {\r\n                this.stop();\r\n            }\r\n            this.scheduleAtTime(this.getSongPlayTime());\r\n        };\r\n        this.onTimeDataUpdate = () => {\r\n            const songPlayTime = this.getSongPlayTime();\r\n            this.timeData = {\r\n                playTime: songPlayTime,\r\n                playMusicTime: musictime_1.default.fromTime(songPlayTime, this.song.bpm),\r\n            };\r\n        };\r\n        this.context = context;\r\n        // todo allow external sample manager?\r\n        this.sampleManager = new sample_manager_1.default(this.context, samplesBasePath, samplesExtension);\r\n        this.samplePlayer = new SamplePlayer_1.default(this.context, this.context.destination);\r\n        // create interval to start when scheduling\r\n        this.scheduleInterval = new Interval_1.default(this.onScheduleInterval, this.scheduleTime.interval);\r\n        this.timeDataUpdater = new AnimationFrame_1.default(this.onTimeDataUpdate);\r\n    }\r\n    /**\r\n     * Sets the state and dispatches an event.\r\n     * @param {SequencePlayerState} state\r\n     */\r\n    setState(state) {\r\n        if (state !== this.state) {\r\n            this.state = state;\r\n            this.dispatchEvent(new event_1.SequencePlayerEvent('state-change', this.state));\r\n        }\r\n    }\r\n    /**\r\n     * Loads all samples in a song, and sets a reference to the sample on all SampleEvents in each sequence.\r\n     * @param {Song} song\r\n     * @param {string} extension\r\n     * @param {() => void} onProgress\r\n     * @returns {Promise<void>}\r\n     */\r\n    loadSong(song, onProgress) {\r\n        if (this.state !== enum_1.SequencePlayerState.IDLE) {\r\n            return Promise.reject('Can only load when idle');\r\n        }\r\n        this.setState(enum_1.SequencePlayerState.LOADING);\r\n        return this.sampleManager\r\n            .loadSamplesByName(song.getUsedSampleNames(), onProgress)\r\n            .then(() => {\r\n            songUtils_1.setSamplesOnSampleEvents(song, this.sampleManager);\r\n            this.setState(enum_1.SequencePlayerState.IDLE);\r\n        })\r\n            .catch(e => {\r\n            this.setState(enum_1.SequencePlayerState.IDLE);\r\n            return Promise.reject(e);\r\n        });\r\n    }\r\n    /**\r\n     * Play a song at the given bpm.\r\n     * @param {Song} song\r\n     * @param {boolean} updateTimeData\r\n     */\r\n    play(song, updateTimeData = true) {\r\n        // todo return promise?\r\n        if (this.state !== enum_1.SequencePlayerState.IDLE) {\r\n            console.error('Can only play when idle');\r\n            return;\r\n        }\r\n        this.song = song;\r\n        let loadPromise;\r\n        if (song.getIsLoaded()) {\r\n            loadPromise = Promise.resolve();\r\n        }\r\n        else {\r\n            loadPromise = this.loadSong(song);\r\n        }\r\n        loadPromise.then(() => {\r\n            this.setState(enum_1.SequencePlayerState.PLAYING);\r\n            // store start time, so we know where we are in the song\r\n            this.playStartTime = this.context.currentTime;\r\n            // start timedata updater\r\n            if (updateTimeData) {\r\n                this.timeDataUpdater.start();\r\n            }\r\n            // do one schedule call for time=0\r\n            this.scheduleAtTime(0);\r\n            // and more on interval\r\n            this.scheduleInterval.start();\r\n        });\r\n    }\r\n    /**\r\n     * Schedules all events from time to time+lookahead\r\n     * @param {number} playTime\r\n     */\r\n    scheduleAtTime(playTime) {\r\n        // get all events in the timewindow\r\n        const endTime = playTime + this.scheduleTime.lookAhead;\r\n        const items = scheduleUtils_1.getEventScheduleList(playTime, endTime, this.song);\r\n        items.forEach(item => {\r\n            //\r\n            this.samplePlayer.playSample(item, this.playStartTime);\r\n        });\r\n    }\r\n    stop() {\r\n        if (this.state !== enum_1.SequencePlayerState.PLAYING) {\r\n            console.error('Can only stop when playing');\r\n            return;\r\n        }\r\n        this.scheduleInterval.stop();\r\n        this.samplePlayer.stopAll();\r\n        this.timeDataUpdater.stop();\r\n        this.timeData = sequencePlayerUtils_1.initTimeData();\r\n        scheduleUtils_1.clearAllLastScheduleData(this.song);\r\n        this.setState(enum_1.SequencePlayerState.IDLE);\r\n    }\r\n    /**\r\n     * Returns the time in seconds that the song is playing.\r\n     * @returns {number}\r\n     */\r\n    getSongPlayTime() {\r\n        return this.context.currentTime - this.playStartTime;\r\n    }\r\n    /**\r\n     * Returns the current state\r\n     * @returns {SequencePlayerState}\r\n     */\r\n    getState() {\r\n        return this.state;\r\n    }\r\n    dispose() {\r\n        // todo\r\n        super.dispose();\r\n    }\r\n}\r\nexports.default = SequencePlayer;\r\n//\r\n// export class SequencePlayerEvent extends AbstractEvent {\r\n//   public static STATE_CHANGE:string = EVENT_TYPE_PLACEHOLDER;\r\n// }\r\n\n\n//# sourceURL=webpack:///../src/lib/SequencePlayer.ts?");

/***/ }),

/***/ "../src/lib/Song.ts":
/*!**************************!*\
  !*** ../src/lib/Song.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst musictime_1 = __webpack_require__(/*! musictime */ \"../node_modules/musictime/index.js\");\r\nconst enum_1 = __webpack_require__(/*! ./data/enum */ \"../src/lib/data/enum.ts\");\r\nconst songUtils_1 = __webpack_require__(/*! ./util/songUtils */ \"../src/lib/util/songUtils.ts\");\r\nclass Song {\r\n    constructor(bpm) {\r\n        // todo make more stuff private?\r\n        this.timedSequences = [];\r\n        this.loopPoints = [];\r\n        this.sequences = []; // unique sequences\r\n        this.usedSampleNames = []; // used by the player to decide what to load\r\n        this.sections = [];\r\n        this.songEndTime = new musictime_1.default(0, 0, 0);\r\n        // todo force bpm within a range\r\n        this.bpm = bpm;\r\n    }\r\n    /**\r\n     * Adds a sequence to the song\r\n     * @param {ISequence} sequence\r\n     * @param {MusicTime} time\r\n     */\r\n    addSequenceAtTime(sequence, time) {\r\n        // check if there is another sequence with the same id (same id is allowed, but only when it's the same instance)\r\n        const seqWithSameId = this.sequences.find(existingSequence => existingSequence.id === sequence.id);\r\n        if (seqWithSameId && seqWithSameId !== sequence) {\r\n            throw new Error(`There is already a different sequence with id ${sequence.id}`);\r\n        }\r\n        // add unique sequences to the list\r\n        if (!seqWithSameId) {\r\n            this.sequences.push(sequence);\r\n        }\r\n        // add sequence with time, and give an id to the combination\r\n        this.timedSequences.push({\r\n            sequence,\r\n            absoluteStart: time,\r\n            id: `${this.timedSequences.length + 1}`,\r\n        });\r\n        sequence.events.forEach(event => {\r\n            // if there are samples in the sequence, add their name to the list\r\n            if (event.type === enum_1.SequenceEventType.SAMPLE &&\r\n                this.usedSampleNames.indexOf(event.sampleName) === -1) {\r\n                this.usedSampleNames.push(event.sampleName);\r\n            }\r\n        });\r\n        this.songEndTime = songUtils_1.getSongEndTime(this);\r\n    }\r\n    addSection(start, end) {\r\n        this.sections.push({\r\n            start,\r\n            end,\r\n        });\r\n    }\r\n    getSections() {\r\n        return this.sections;\r\n    }\r\n    getUsedSampleNames() {\r\n        return this.usedSampleNames;\r\n    }\r\n    getSongEndTime() {\r\n        return this.songEndTime;\r\n    }\r\n    /**\r\n     * Returns true if all ISampleEvents have a reference to a sample, and those samples are loaded.\r\n     * @returns {boolean}\r\n     */\r\n    getIsLoaded() {\r\n        for (let s = 0; s < this.sequences.length; s++) {\r\n            const sequence = this.sequences[s];\r\n            for (let e = 0; e < sequence.events.length; e++) {\r\n                const sequenceEvent = sequence.events[e];\r\n                if ((sequenceEvent.type === enum_1.SequenceEventType.SAMPLE &&\r\n                    !sequenceEvent.sample) ||\r\n                    !sequenceEvent.sample.audioBuffer) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    updateSongDuration() { }\r\n}\r\nexports.default = Song;\r\n\n\n//# sourceURL=webpack:///../src/lib/Song.ts?");

/***/ }),

/***/ "../src/lib/data/enum.ts":
/*!*******************************!*\
  !*** ../src/lib/data/enum.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar SequenceEventType;\r\n(function (SequenceEventType) {\r\n    SequenceEventType[\"SAMPLE\"] = \"sample\";\r\n    SequenceEventType[\"NOTE\"] = \"note\";\r\n})(SequenceEventType = exports.SequenceEventType || (exports.SequenceEventType = {}));\r\nvar SequencePlayerState;\r\n(function (SequencePlayerState) {\r\n    SequencePlayerState[\"IDLE\"] = \"idle\";\r\n    SequencePlayerState[\"LOADING\"] = \"loading\";\r\n    SequencePlayerState[\"PLAYING\"] = \"playing\";\r\n})(SequencePlayerState = exports.SequencePlayerState || (exports.SequencePlayerState = {}));\r\n\n\n//# sourceURL=webpack:///../src/lib/data/enum.ts?");

/***/ }),

/***/ "../src/lib/data/event.ts":
/*!********************************!*\
  !*** ../src/lib/data/event.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst AbstractEvent_1 = __webpack_require__(/*! seng-event/lib/AbstractEvent */ \"../node_modules/seng-event/lib/AbstractEvent.js\");\r\nclass SequencePlayerEvent extends AbstractEvent_1.default {\r\n    constructor(type, data, bubbles = false, cancelable = false, setTimeStamp = false) {\r\n        super(type, bubbles, cancelable, setTimeStamp);\r\n        this.data = data;\r\n    }\r\n    clone() {\r\n        return new SequencePlayerEvent(this.type, this.data, this.bubbles, this.cancelable, this.timeStamp !== 0);\r\n    }\r\n}\r\nexports.SequencePlayerEvent = SequencePlayerEvent;\r\n\n\n//# sourceURL=webpack:///../src/lib/data/event.ts?");

/***/ }),

/***/ "../src/lib/editor/Editor.ts":
/*!***********************************!*\
  !*** ../src/lib/editor/Editor.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst sequenceUtils_1 = __webpack_require__(/*! ../util/sequenceUtils */ \"../src/lib/util/sequenceUtils.ts\");\r\nconst musictime_1 = __webpack_require__(/*! musictime */ \"../node_modules/musictime/index.js\");\r\nconst editorUtils_1 = __webpack_require__(/*! ../util/editorUtils */ \"../src/lib/util/editorUtils.ts\");\r\nconst AnimationFrame_1 = __webpack_require__(/*! ../util/AnimationFrame */ \"../src/lib/util/AnimationFrame.ts\");\r\nconst enum_1 = __webpack_require__(/*! ../data/enum */ \"../src/lib/data/enum.ts\");\r\nclass Editor {\r\n    constructor(element, player) {\r\n        this.pixelsPerSecond = 40;\r\n        this.defaultEventDuration = musictime_1.default.fromString('0.0.1');\r\n        this.sequenceHeight = 70;\r\n        this.colors = ['#b3d9ff', '#66b3ff'];\r\n        this.seqsOffset = { x: 30, y: 110 };\r\n        this.seqLabelheight = 15;\r\n        this.seqSpacing = { x: 1, y: 1 };\r\n        this.timelineHeight = 30;\r\n        this.timelineSpacing = 20;\r\n        this.updateFrame = new AnimationFrame_1.default(this.onUpdate.bind(this));\r\n        this.element = element;\r\n        element.style.position = 'relative';\r\n        element.style.backgroundColor = '#444';\r\n        this.player = player;\r\n        player.addEventListener('state-change', (event) => {\r\n            switch (event.data) {\r\n                case enum_1.SequencePlayerState.IDLE: {\r\n                    this.updateFrame.stop();\r\n                    this.updatePlayheadPosition();\r\n                    break;\r\n                }\r\n                case enum_1.SequencePlayerState.PLAYING: {\r\n                    this.updateFrame.start();\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n        // playhead\r\n        const x = this.seqsOffset.x + this.player.timeData.playTime * this.pixelsPerSecond;\r\n        const y = this.seqsOffset.y;\r\n        this.playHead = editorUtils_1.createVerticalLine(0, { x, y }, 'red'); // height will be set later\r\n        this.element.appendChild(this.playHead);\r\n        // song end\r\n        this.songEnd = editorUtils_1.createVerticalLine(0, { x, y }, 'lime'); // height will be set later\r\n        this.element.appendChild(this.songEnd);\r\n        this.timeLineContext = editorUtils_1.createTimelineCanvas(element, this.timelineHeight, this.seqsOffset.y - this.timelineHeight - this.timelineSpacing);\r\n    }\r\n    onUpdate() {\r\n        this.updatePlayheadPosition();\r\n    }\r\n    setSong(song) {\r\n        this.song = song;\r\n        this.drawSong();\r\n        this.setLineHeights();\r\n        editorUtils_1.drawTimeline(this.timeLineContext, this.seqsOffset.x, this.pixelsPerSecond, this.song.bpm);\r\n        // set song end\r\n        this.songEnd.style.left = `${this.seqsOffset.x +\r\n            editorUtils_1.musicTimeToPixels(song.getSongEndTime(), song.bpm, this.pixelsPerSecond)}px`;\r\n    }\r\n    drawSong() {\r\n        // draw sequences\r\n        this.song.timedSequences.forEach(timedSequence => {\r\n            const sequenceIndex = this.song.sequences.indexOf(timedSequence.sequence);\r\n            // seq\r\n            const x = this.seqsOffset.x + this.musicTimeToPixels(timedSequence.absoluteStart);\r\n            const y = this.seqsOffset.y + sequenceIndex * (this.sequenceHeight + this.seqSpacing.y);\r\n            const width = this.getSequenceWidth(timedSequence.sequence) - this.seqSpacing.x;\r\n            const height = this.sequenceHeight;\r\n            const el = editorUtils_1.createSequenceElement(timedSequence.sequence, { x, y }, {\r\n                width,\r\n                height,\r\n            }, this.colors[sequenceIndex % 2], this.seqLabelheight, this.pixelsPerSecond, this.song.bpm, this.musicTimeToPixels(this.defaultEventDuration));\r\n            this.element.appendChild(el);\r\n        });\r\n        // draw sections\r\n        const sections = this.song.getSections();\r\n        sections.forEach(section => {\r\n            this.element.appendChild(editorUtils_1.createSection(section, {\r\n                x: this.seqsOffset.x + this.musicTimeToPixels(section.start),\r\n                y: this.seqsOffset.y - 20,\r\n            }, { width: this.musicTimeToPixels(section.end.subtract(section.start)), height: 10 }));\r\n        });\r\n    }\r\n    updatePlayheadPosition() {\r\n        const x = this.seqsOffset.x + this.player.timeData.playTime * this.pixelsPerSecond;\r\n        this.playHead.style.left = `${x}px`;\r\n    }\r\n    setLineHeights() {\r\n        const height = this.song.sequences.length * (this.sequenceHeight + this.seqSpacing.y) - this.seqSpacing.y;\r\n        this.playHead.style.height = `${height}px`;\r\n        this.songEnd.style.height = `${height}px`;\r\n    }\r\n    getSequenceWidth(sequence) {\r\n        const latestEvent = sequenceUtils_1.getLatestEventInSequence(sequence);\r\n        // ceil to next bar\r\n        const seqEndTime = new musictime_1.default(latestEvent.relativeStart.bars + 1, 0, 0);\r\n        return this.musicTimeToPixels(seqEndTime);\r\n    }\r\n    musicTimeToPixels(musicTime) {\r\n        return editorUtils_1.musicTimeToPixels(musicTime, this.song.bpm, this.pixelsPerSecond);\r\n    }\r\n}\r\nexports.default = Editor;\r\n\n\n//# sourceURL=webpack:///../src/lib/editor/Editor.ts?");

/***/ }),

/***/ "../src/lib/util/AnimationFrame.ts":
/*!*****************************************!*\
  !*** ../src/lib/util/AnimationFrame.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass AnimationFrame {\r\n    // private requestAnimationFrameId: number;\r\n    constructor(callback) {\r\n        this.stopped = false;\r\n        this.update = () => {\r\n            if (!this.stopped) {\r\n                this.callback();\r\n                requestAnimationFrame(this.update);\r\n            }\r\n        };\r\n        this.callback = callback;\r\n    }\r\n    start() {\r\n        this.stopped = false;\r\n        this.update();\r\n    }\r\n    stop() {\r\n        // cancelAnimationFrame(this.requestAnimationFrameId);\r\n        this.stopped = true;\r\n    }\r\n}\r\nexports.default = AnimationFrame;\r\n\n\n//# sourceURL=webpack:///../src/lib/util/AnimationFrame.ts?");

/***/ }),

/***/ "../src/lib/util/Interval.ts":
/*!***********************************!*\
  !*** ../src/lib/util/Interval.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass Interval {\r\n    constructor(callback, interval) {\r\n        this.isRunning = false;\r\n        this.callback = callback;\r\n        this.interval = interval;\r\n    }\r\n    start() {\r\n        if (this.isRunning) {\r\n            console.error('Interval is already running');\r\n            return;\r\n        }\r\n        this.isRunning = true;\r\n        this.intervalId = window.setInterval(this.callback, this.interval * 1000);\r\n    }\r\n    stop() {\r\n        this.isRunning = false;\r\n        clearInterval(this.intervalId);\r\n    }\r\n    dispose() {\r\n        this.stop();\r\n    }\r\n}\r\nexports.default = Interval;\r\n\n\n//# sourceURL=webpack:///../src/lib/util/Interval.ts?");

/***/ }),

/***/ "../src/lib/util/editorUtils.ts":
/*!**************************************!*\
  !*** ../src/lib/util/editorUtils.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst musictime_1 = __webpack_require__(/*! musictime */ \"../node_modules/musictime/index.js\");\r\nfunction createSequenceElement(sequence, position, size, color, labelHeight, pixelsPerSecond, bpm, eventWidth, eventVerticalSpread = 3) {\r\n    const wrapper = createRectElement(position, size, color);\r\n    const label = document.createElement('p');\r\n    label.innerText = sequence.id;\r\n    label.style.margin = '0px';\r\n    label.style.padding = '1px 4px';\r\n    label.style.height = `${labelHeight}px`;\r\n    label.style.backgroundColor = 'rgba(0,0,0,0.4)';\r\n    label.style.color = 'white';\r\n    label.style.boxSizing = 'border-box';\r\n    label.style.fontSize = '11px';\r\n    wrapper.appendChild(label);\r\n    const eventWrapHeight = size.height - labelHeight;\r\n    const eventWrap = document.createElement('div');\r\n    eventWrap.style.height = `${eventWrapHeight}px`;\r\n    eventWrap.style.position = 'relative';\r\n    wrapper.appendChild(eventWrap);\r\n    const eventHeight = eventWrapHeight / eventVerticalSpread;\r\n    sequence.events.forEach((event, index) => {\r\n        const pos = {\r\n            x: musicTimeToPixels(event.relativeStart, bpm, pixelsPerSecond),\r\n            y: (index % eventVerticalSpread) * eventHeight,\r\n        };\r\n        const size = {\r\n            width: eventWidth - 1,\r\n            height: eventHeight - 1,\r\n        };\r\n        const eventEl = createRectElement(pos, size, 'rgba(255,255,255,1)');\r\n        eventEl.innerText = event.sampleName[0];\r\n        eventEl.title = event.sampleName;\r\n        eventWrap.appendChild(eventEl);\r\n    });\r\n    return wrapper;\r\n}\r\nexports.createSequenceElement = createSequenceElement;\r\nfunction createSection(section, position, size) {\r\n    const wrapper = createRectElement(position, size, '#00cc00');\r\n    // const label = document.createElement('p');\r\n    // label.innerText = 'section';\r\n    // label.style.margin = '0px';\r\n    // label.style.padding = '2px';\r\n    // label.style.backgroundColor = 'rgba(0,0,0,0.4)';\r\n    // label.style.color = 'white';\r\n    // label.style.fontSize = '11px';\r\n    // wrapper.appendChild(label);\r\n    return wrapper;\r\n}\r\nexports.createSection = createSection;\r\nfunction createRectElement(position, size, color) {\r\n    const el = document.createElement('div');\r\n    el.style.width = `${size.width}px`;\r\n    el.style.height = `${size.height}px`;\r\n    el.style.left = `${position.x}px`;\r\n    el.style.top = `${position.y}px`;\r\n    el.style.position = `absolute`;\r\n    el.style.backgroundColor = color;\r\n    return el;\r\n}\r\nexports.createRectElement = createRectElement;\r\nfunction createTimelineCanvas(parent, height, yOffset) {\r\n    const canvas = document.createElement('canvas');\r\n    const timeLineContext = canvas.getContext('2d');\r\n    canvas.width = parseInt(parent.style.width, 10);\r\n    canvas.height = height;\r\n    canvas.style.position = 'absolute';\r\n    canvas.style.top = `${yOffset}px`;\r\n    parent.appendChild(canvas);\r\n    return timeLineContext;\r\n}\r\nexports.createTimelineCanvas = createTimelineCanvas;\r\nfunction drawTimeline(context, xDrawOffset, pixelsPerSecond, bpm) {\r\n    context.fillStyle = 'black';\r\n    context.strokeStyle = 'white';\r\n    context.fillRect(0, 0, context.canvas.width, context.canvas.height);\r\n    const beatWidth = new musictime_1.default(0, 1, 0).toTime(bpm) * pixelsPerSecond;\r\n    let xPosition = xDrawOffset;\r\n    let index = 0;\r\n    while (xPosition < context.canvas.width) {\r\n        context.beginPath();\r\n        const x = Math.round(xPosition) + 0.5;\r\n        context.moveTo(x, context.canvas.height);\r\n        let lineWidth = 0.5;\r\n        let lineLength = 0.25;\r\n        // if (index % 4 === 0) {\r\n        //   lineWidth = 2;\r\n        //\r\n        // }\r\n        if (index % 4 === 0) {\r\n            lineWidth = 2;\r\n            lineLength = 0.4;\r\n        }\r\n        const lineEndY = context.canvas.height - context.canvas.height * lineLength;\r\n        context.lineTo(x, lineEndY);\r\n        context.lineWidth = lineWidth;\r\n        context.stroke();\r\n        if (lineWidth === 2) {\r\n            context.fillStyle = 'white';\r\n            context.textAlign = 'center';\r\n            context.fillText(new musictime_1.default(0, index, 0).toString(), x, lineEndY - 3);\r\n        }\r\n        xPosition += beatWidth;\r\n        index += 1;\r\n    }\r\n}\r\nexports.drawTimeline = drawTimeline;\r\nfunction musicTimeToPixels(musicTime, bpm, pixelsPerSecond) {\r\n    return musicTime.toTime(bpm) * pixelsPerSecond;\r\n}\r\nexports.musicTimeToPixels = musicTimeToPixels;\r\nfunction createVerticalLine(height, pos, color) {\r\n    const div = document.createElement('div');\r\n    div.style.width = `${1}px`;\r\n    div.style.height = `${height}px`;\r\n    div.style.left = `${pos.x}px`;\r\n    div.style.top = `${pos.y}px`;\r\n    div.style.position = 'absolute';\r\n    div.style.zIndex = '999';\r\n    div.style.backgroundColor = color;\r\n    return div;\r\n}\r\nexports.createVerticalLine = createVerticalLine;\r\n\n\n//# sourceURL=webpack:///../src/lib/util/editorUtils.ts?");

/***/ }),

/***/ "../src/lib/util/scheduleUtils.ts":
/*!****************************************!*\
  !*** ../src/lib/util/scheduleUtils.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/**\r\n * Returns all ISequenceEvents whose time is in a given time window\r\n * @param {number} fromTime\r\n * @param {number} toTime\r\n * @param {Song} song\r\n * @returns {ISequenceEvent[]}\r\n */\r\nfunction getEventScheduleList(fromTime, toTime, song) {\r\n    const results = [];\r\n    for (let ts = 0; ts < song.timedSequences.length; ts++) {\r\n        // start time for this sequence\r\n        const timedSequence = song.timedSequences[ts];\r\n        const sequenceStart = timedSequence.absoluteStart.toTime(song.bpm);\r\n        // loop through events for sequence\r\n        for (let e = 0; e < timedSequence.sequence.events.length; e++) {\r\n            const event = timedSequence.sequence.events[e];\r\n            // skip if event was already scheduled in a previous call\r\n            if (eventHasBeenScheduled(song, event, timedSequence)) {\r\n                continue;\r\n            }\r\n            // calculate the absolute time for the event\r\n            const absoluteSeconds = sequenceStart + event.relativeStart.toTime(song.bpm);\r\n            // and add to results if it's in the timewindow\r\n            if (absoluteSeconds >= fromTime && absoluteSeconds < toTime) {\r\n                results.push({\r\n                    event,\r\n                    absoluteSeconds,\r\n                });\r\n                // and mark as scheduled\r\n                markEventAsScheduled(song, event, timedSequence);\r\n            }\r\n        }\r\n    }\r\n    return results;\r\n}\r\nexports.getEventScheduleList = getEventScheduleList;\r\n/**\r\n * Checks if the event was already scheduled in a previous schedule-call\r\n * @param {Song} song\r\n * @param {ISequenceEvent} event\r\n * @param {ITimedSequence} timedSequence\r\n * @returns {boolean}\r\n */\r\nfunction eventHasBeenScheduled(song, event, timedSequence) {\r\n    if (song.loopPoints.length === 0) {\r\n        // when there are no loop-points, a scheduled event has a value 1 for the id of the timedSequence it is in\r\n        return event.lastScheduledData[timedSequence.id] === 1;\r\n    }\r\n    // todo\r\n    return false;\r\n}\r\n/**\r\n * Marks the event as scheduled.\r\n * @param {Song} song\r\n * @param {ISequenceEvent} event\r\n * @param {ITimedSequence} timedSequence\r\n */\r\nfunction markEventAsScheduled(song, event, timedSequence) {\r\n    if (song.loopPoints.length === 0) {\r\n        event.lastScheduledData[timedSequence.id] = 1;\r\n    }\r\n    // todo else\r\n}\r\nfunction clearAllLastScheduleData(song) {\r\n    for (let s = 0; s < song.sequences.length; s++) {\r\n        for (let e = 0; e < song.sequences[s].events.length; e++) {\r\n            song.sequences[s].events[e].lastScheduledData = {};\r\n        }\r\n    }\r\n}\r\nexports.clearAllLastScheduleData = clearAllLastScheduleData;\r\n\n\n//# sourceURL=webpack:///../src/lib/util/scheduleUtils.ts?");

/***/ }),

/***/ "../src/lib/util/sequencePlayerUtils.ts":
/*!**********************************************!*\
  !*** ../src/lib/util/sequencePlayerUtils.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst musictime_1 = __webpack_require__(/*! musictime */ \"../node_modules/musictime/index.js\");\r\nfunction initTimeData() {\r\n    return { playTime: 0, playMusicTime: new musictime_1.default(0, 0, 0) };\r\n}\r\nexports.initTimeData = initTimeData;\r\n\n\n//# sourceURL=webpack:///../src/lib/util/sequencePlayerUtils.ts?");

/***/ }),

/***/ "../src/lib/util/sequenceUtils.ts":
/*!****************************************!*\
  !*** ../src/lib/util/sequenceUtils.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst enum_1 = __webpack_require__(/*! ../data/enum */ \"../src/lib/data/enum.ts\");\r\nconst musictime_1 = __webpack_require__(/*! musictime */ \"../node_modules/musictime/index.js\");\r\n/**\r\n * Creates a sequence with samplesEvents.\r\n * @param {string} id\r\n * @param {ICreateSampleEvents} events\r\n * @returns {ISequence}\r\n */\r\nfunction createSampleSequence(id, events) {\r\n    const sequence = {\r\n        id,\r\n        target: null,\r\n        events: [],\r\n    };\r\n    const timeKeys = Object.keys(events);\r\n    if (timeKeys.length === 0) {\r\n        throw new Error(\"Can't create a sequence without events\");\r\n    }\r\n    Object.keys(events).forEach(musicTimeString => {\r\n        const dataList = events[musicTimeString];\r\n        for (let i = 0; i < dataList.length; i += 2) {\r\n            const sampleName = dataList[i]; // todo check and test type and correct values of these two\r\n            const volume = dataList[i + 1] || 1;\r\n            // volume may be left out, but can only happen when assigning one sample: {'0.0.0': ['sample1']}\r\n            if (volume !== void 0 && typeof volume !== 'number') {\r\n                // volume is set, but is not a number. catches this case: '0.0.0': ['sample1', 'sample2']\r\n                throw new TypeError(`Expecting a volume value but found a ${typeof volume}`);\r\n            }\r\n            const sampleEvent = Object.assign({ sampleName,\r\n                volume, sample: null }, createBaseSequenceEventFromTimeString(enum_1.SequenceEventType.SAMPLE, musictime_1.default.fromString(musicTimeString)));\r\n            sequence.events.push(sampleEvent);\r\n        }\r\n    });\r\n    orderEventsInSequence(sequence);\r\n    return sequence;\r\n}\r\nexports.createSampleSequence = createSampleSequence;\r\nfunction orderEventsInSequence(sequence) {\r\n    sequence.events.sort((a, b) => {\r\n        return a.relativeStart.toSixteenths() - b.relativeStart.toSixteenths();\r\n    });\r\n}\r\n/**\r\n * Creates an ISequenceEvent object with properties that all extended types share.\r\n * @param {SequenceEventType} type\r\n * @param {MusicTime} musicTime\r\n * @returns {ISequenceEvent}\r\n */\r\nfunction createBaseSequenceEventFromTimeString(type, musicTime) {\r\n    return {\r\n        type,\r\n        relativeStart: musicTime,\r\n        lastScheduledData: {},\r\n    };\r\n}\r\nfunction getLatestEventInSequence(sequence) {\r\n    let latestTime = 0;\r\n    let latestEvent;\r\n    sequence.events.forEach(event => {\r\n        const eventStart = event.relativeStart.toSixteenths();\r\n        if (eventStart > latestTime) {\r\n            latestEvent = event;\r\n            latestTime = eventStart;\r\n        }\r\n    });\r\n    return latestEvent;\r\n}\r\nexports.getLatestEventInSequence = getLatestEventInSequence;\r\n\n\n//# sourceURL=webpack:///../src/lib/util/sequenceUtils.ts?");

/***/ }),

/***/ "../src/lib/util/songUtils.ts":
/*!************************************!*\
  !*** ../src/lib/util/songUtils.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst enum_1 = __webpack_require__(/*! ../data/enum */ \"../src/lib/data/enum.ts\");\r\nconst musictime_1 = __webpack_require__(/*! musictime */ \"../node_modules/musictime/index.js\");\r\nfunction setSamplesOnSampleEvents(song, sampleManager) {\r\n    for (let s = 0; s < song.sequences.length; s++) {\r\n        for (let e = 0; e < song.sequences[s].events.length; e++) {\r\n            const event = song.sequences[s].events[e];\r\n            if (event.type === enum_1.SequenceEventType.SAMPLE) {\r\n                event.sample = sampleManager.getSampleByName(event.sampleName);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.setSamplesOnSampleEvents = setSamplesOnSampleEvents;\r\n// todo pass a reference time (so we dont have to check everything again)\r\n// todo this whole thing can probably be optimized a lot\r\nfunction getSongEndTime(song) {\r\n    let latestTime = new musictime_1.default(0, 0, 0);\r\n    song.timedSequences.forEach(ts => {\r\n        ts.sequence.events.forEach(e => {\r\n            // todo this should also take in consideration the length of the sample (or whatever other event types there will be)\r\n            const eventTime = ts.absoluteStart.add(e.relativeStart);\r\n            if (eventTime.toSixteenths() > latestTime.toSixteenths()) {\r\n                latestTime = eventTime;\r\n            }\r\n        });\r\n    });\r\n    // ceil to next bar\r\n    return new musictime_1.default(latestTime.bars + 1, 0, 0);\r\n}\r\nexports.getSongEndTime = getSongEndTime;\r\n// export function logSong(song: Song): void {\r\n//   console.log(song);\r\n//   song.timedSequences.forEach(timedSequence => {\r\n//     console.log(`--- ${timedSequence.sequence.id} (${timedSequence.absoluteStart.toString()}) ---`);\r\n//     logSequence(timedSequence.sequence);\r\n//   });\r\n// }\r\n/**\r\n * Calculates the duration of the song\r\n * @param {Song} song\r\n * @returns {number}\r\n */\r\n// export function getSongDuration(song: Song): number {\r\n//   let latestTime = 0;\r\n//   song.timedSequences.forEach(timedSequence => {\r\n//     const sequenceStartTime = timedSequence.absoluteStart.toTime(song.bpm);\r\n//   })\r\n// }\r\n\n\n//# sourceURL=webpack:///../src/lib/util/songUtils.ts?");

/***/ }),

/***/ "../src/lib/util/webAudioUtils.ts":
/*!****************************************!*\
  !*** ../src/lib/util/webAudioUtils.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nfunction playBuffer(context, destination, buffer, time, from, duration = -1, volume = 1) {\r\n    if (time < context.currentTime) {\r\n        // time is already in the past\r\n        return null;\r\n    }\r\n    // create nodes\r\n    const gainNode = context.createGain();\r\n    const bufferSourceNode = context.createBufferSource();\r\n    // init volume and sampledata\r\n    gainNode.gain.value = volume;\r\n    bufferSourceNode.buffer = buffer;\r\n    // make connections\r\n    bufferSourceNode.connect(gainNode);\r\n    gainNode.connect(destination);\r\n    // start\r\n    bufferSourceNode.start(time, from, duration === -1 ? void 0 : duration);\r\n    return {\r\n        bufferSourceNode,\r\n        gainNode,\r\n    };\r\n}\r\nexports.playBuffer = playBuffer;\r\n\n\n//# sourceURL=webpack:///../src/lib/util/webAudioUtils.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Song_1 = __webpack_require__(/*! ../../src/lib/Song */ \"../src/lib/Song.ts\");\r\nconst sequenceUtils_1 = __webpack_require__(/*! ../../src/lib/util/sequenceUtils */ \"../src/lib/util/sequenceUtils.ts\");\r\nconst SequencePlayer_1 = __webpack_require__(/*! ../../src/lib/SequencePlayer */ \"../src/lib/SequencePlayer.ts\");\r\nconst musictime_1 = __webpack_require__(/*! musictime */ \"../node_modules/musictime/index.js\");\r\nconst AnimationFrame_1 = __webpack_require__(/*! ../../src/lib/util/AnimationFrame */ \"../src/lib/util/AnimationFrame.ts\");\r\nconst Editor_1 = __webpack_require__(/*! ../../src/lib/editor/Editor */ \"../src/lib/editor/Editor.ts\");\r\nconst stateElement = document.querySelector('#state');\r\nconst timeElement = document.querySelector('#time');\r\nconst showPlayerState = state => {\r\n    stateElement.innerText = state;\r\n};\r\nconst context = new AudioContext();\r\nconst player = new SequencePlayer_1.default(context, 'samples/', 'wav');\r\nplayer.sampleManager.addSamplesFromNames(['kick', 'clap', 'synth', 'snare', 'hihat']);\r\nshowPlayerState(player.getState());\r\nplayer.addEventListener('state-change', (event) => {\r\n    showPlayerState(event.data);\r\n});\r\nconst animationFrame = new AnimationFrame_1.default(() => {\r\n    const musicTime = player.timeData.playMusicTime;\r\n    timeElement.innerText = `${musicTime.bars}.${musicTime.beats}.${musicTime.sixteenths}`;\r\n});\r\nanimationFrame.start();\r\nconst data1 = {\r\n    '0.0.0': ['kick', 1, 'synth', 1],\r\n    '0.1.0': ['kick', 1, 'clap', 1],\r\n    '0.2.0': ['kick', 1],\r\n    '0.3.0': ['kick', 1, 'clap', 1],\r\n    '1.0.0': ['kick', 1],\r\n    '1.1.0': ['kick', 1, 'clap', 1],\r\n    '1.2.0': ['kick', 1],\r\n    '1.3.0': ['kick', 1, 'clap', 1],\r\n    '2.0.0': ['kick', 1],\r\n    '2.1.0': ['clap', 1],\r\n    '2.2.0': [],\r\n    '2.3.0': ['clap', 1],\r\n    '3.0.0': ['kick', 1],\r\n    '3.1.0': ['clap', 1],\r\n    '3.2.0': [],\r\n    '3.3.0': ['clap', 1],\r\n};\r\nconst data2 = {\r\n    '0.2.2': ['snare'],\r\n    '1.3.0': ['snare'],\r\n    '2.2.2': ['snare'],\r\n    '3.0.0': ['snare', 1 / 8],\r\n    '3.0.2': ['snare', 2 / 8],\r\n    '3.1.0': ['snare', 3 / 8],\r\n    '3.1.2': ['snare', 4 / 8],\r\n    '3.2.0': ['snare', 5 / 8],\r\n    '3.2.2': ['snare', 6 / 8],\r\n    '3.3.0': ['snare', 7 / 8],\r\n    '3.3.2': ['snare', 8 / 8],\r\n};\r\nconst data3 = {\r\n    '0.0.0': ['hihat'],\r\n    '0.0.1': ['hihat'],\r\n    '0.0.2': ['hihat'],\r\n    '0.0.3': ['hihat'],\r\n};\r\nconst song = new Song_1.default(128);\r\nconst seq1 = sequenceUtils_1.createSampleSequence('seq1', data1);\r\nconst seq2 = sequenceUtils_1.createSampleSequence('snare', data2);\r\nconst seq3 = sequenceUtils_1.createSampleSequence('hihat', data3);\r\nsong.addSequenceAtTime(seq1, new musictime_1.default(0, 0, 0));\r\nsong.addSequenceAtTime(seq1, new musictime_1.default(4, 0, 0));\r\nsong.addSequenceAtTime(seq1, new musictime_1.default(8, 0, 0));\r\nsong.addSequenceAtTime(seq2, new musictime_1.default(0, 0, 0));\r\nsong.addSequenceAtTime(seq2, new musictime_1.default(4, 0, 0));\r\nsong.addSequenceAtTime(seq3, new musictime_1.default(4, 0, 0));\r\nsong.addSequenceAtTime(seq3, new musictime_1.default(5, 0, 0));\r\nsong.addSequenceAtTime(seq3, new musictime_1.default(6, 0, 0));\r\nsong.addSequenceAtTime(seq3, new musictime_1.default(7, 0, 0));\r\ndocument.querySelector('#start').addEventListener('click', () => {\r\n    // player.loadSong(song).then(() => {\r\n    //\r\n    //   console.log('done');\r\n    // });\r\n    player.play(song);\r\n});\r\ndocument.querySelector('#stop').addEventListener('click', () => {\r\n    player.stop();\r\n    console.log(musictime_1.default.TO_TIME_CACHE);\r\n});\r\nconst editor = new Editor_1.default(document.querySelector('#editor'), player);\r\nsong.addSection(musictime_1.default.fromString('4.0.0'), musictime_1.default.fromString('8.0.0'));\r\neditor.setSong(song);\r\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ })

/******/ });